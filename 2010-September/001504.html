<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Socketcan-users] MCP 2515 RX problems
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/socketcan-users/2010-September/index.html" >
   <LINK REL="made" HREF="mailto:socketcan-users%40lists.berlios.de?Subject=Re%3A%20%5BSocketcan-users%5D%20MCP%202515%20RX%20problems&In-Reply-To=%3CAANLkTikT9HMYZ_h%3DSUqN3Hd-r2M%3DiB%3DHzyOAS1SQjw4%2B%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001501.html">
   <LINK REL="Next"  HREF="001502.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Socketcan-users] MCP 2515 RX problems</H1>
    <B>Erik Calissendorff</B> 
    <A HREF="mailto:socketcan-users%40lists.berlios.de?Subject=Re%3A%20%5BSocketcan-users%5D%20MCP%202515%20RX%20problems&In-Reply-To=%3CAANLkTikT9HMYZ_h%3DSUqN3Hd-r2M%3DiB%3DHzyOAS1SQjw4%2B%40mail.gmail.com%3E"
       TITLE="[Socketcan-users] MCP 2515 RX problems">gumstix at tansaki.com
       </A><BR>
    <I>Sun Sep 12 21:24:30 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001501.html">[Socketcan-users] MCP 2515 RX problems
</A></li>
        <LI>Next message: <A HREF="001502.html">[Socketcan-users] What is the current &quot;main&quot; SocketCAN repo?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1504">[ date ]</a>
              <a href="thread.html#1504">[ thread ]</a>
              <a href="subject.html#1504">[ subject ]</a>
              <a href="author.html#1504">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Hi we are having similar problem with our MCP2515 connected to a Gumstix Overo.

Below is a dump from candump of packages when sending a burst of data
representing &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;
with one character per packet.

 (1279702812.562408)  can0  1A300280  [1] 61
 (1279702812.568237)  can0    4  [8] 00 01 00 00 00 00 00 00
 (1279702812.569458)  can0  1A300280  [1] 67
 (1279702812.571502)  can0  1A300280  [1] 68
 (1279702812.571594)  can0  1A300280  [1] 69
 (1279702812.571899)  can0  1A300280  [1] 6A
 (1279702812.577453)  can0    4  [8] 00 01 00 00 00 00 00 00
 (1279702812.577575)  can0  1A300280  [1] 6F
 (1279702812.581634)  can0    4  [8] 00 01 00 00 00 00 00 00
 (1279702812.581756)  can0  1A300280  [1] 73
 (1279702812.582397)  can0  1A300280  [1] 74
 (1279702812.583129)  can0  1A300280  [1] 75
 (1279702812.584869)  can0  1A300280  [1] 76
 (1279702812.585449)  can0  1A300280  [1] 77
 (1279702812.586273)  can0  1A300280  [1] 78
 (1279702812.587310)  can0  1A300280  [1] 79
 (1279702812.588348)  can0  1A300280  [1] 7A
 (1279702812.589599)  can0  1A300280  [1] 41
 (1279702812.590606)  can0  1A300280  [1] 42
 (1279702812.591613)  can0  1A300280  [1] 43
 (1279702812.592864)  can0  1A300280  [1] 44
 (1279702812.593780)  can0  1A300280  [1] 45
 (1279702812.594604)  can0  1A300280  [1] 46
 (1279702812.595825)  can0  1A300280  [1] 47
 (1279702812.596893)  can0  1A300280  [1] 48
 (1279702812.597930)  can0  1A300280  [1] 49
 (1279702812.599426)  can0  1A300280  [1] 4A
 (1279702812.600646)  can0  1A300280  [1] 4B
 (1279702812.600952)  can0  1A300280  [1] 4C
 (1279702812.602111)  can0  1A300280  [1] 4D
 (1279702812.603118)  can0  1A300280  [1] 4E
 (1279702812.604156)  can0  1A300280  [1] 4F
 (1279702812.605224)  can0  1A300280  [1] 50
 (1279702812.606658)  can0  1A300280  [1] 51
 (1279702812.607269)  can0  1A300280  [1] 52
 (1279702812.608459)  can0  1A300280  [1] 53
 (1279702812.609344)  can0  1A300280  [1] 54
 (1279702812.610992)  can0  1A300280  [1] 55
 (1279702812.611389)  can0  1A300280  [1] 56
 (1279702812.612487)  can0  1A300280  [1] 57
 (1279702812.613494)  can0  1A300280  [1] 58
 (1279702812.615020)  can0  1A300280  [1] 59
 (1279702812.616241)  can0  1A300280  [1] 5A
 (1279702812.616638)  can0  1A300280  [1] 30
 (1279702812.624145)  can0    4  [8] 00 01 00 00 00 00 00 00
 (1279702812.624237)  can0  1A300280  [1] 37
 (1279702812.625061)  can0  1A300280  [1] 38
 (1279702812.625823)  can0  1A300280  [1] 39

As you can see we are getting a number of dropped frames with id 4,
unsure where these frames comes from.

I have applied the patch from Benny mentioned earlier in this thread
to the 2.6.35 kernel, and the result is better then before are now
seeing these id 4 frames.

Is there anything else that I should try?



Kindest regards,

//Erik

On Thu, Sep 2, 2010 at 6:48 AM, Michael Stocks
&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">Michael.Stocks at connexionz.co.nz</A>&gt; wrote:
&gt;<i> Dear All,
</I>&gt;<i> I'm experiencing lost frames and id 0, 8 byte all zero packets now that we have equipment sending back to back packets on a 250Kb network.
</I>&gt;<i> I have plenty of hardware attached to Gumstix Overos so I'll test your patch once the kernel is rebuilt.
</I>&gt;<i>
</I>&gt;<i> Cheers Mike.
</I>&gt;<i>
</I>&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">socketcan-users-bounces at lists.berlios.de</A> [mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">socketcan-users-bounces at lists.berlios.de</A>] On Behalf Of christian pellegrin
</I>&gt;<i> Sent: Thursday, 2 September 2010 02:36
</I>&gt;<i> To: Benny B. Simonsen
</I>&gt;<i> Cc: <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">socketcan-users at lists.berlios.de</A>
</I>&gt;<i> Subject: Re: [Socketcan-users] MCP 2515 RX problems
</I>&gt;<i>
</I>&gt;<i> Hi, first of all sorry for the late response. Just now I managed to put together the needed hardware (you know, in Italy it's near impossible to do anything not related to holidays in august ;-) )
</I>&gt;<i>
</I>&gt;<i> I had a quick look at your patch and it's similar to the one I prepared and I'm attaching below. I think both of them solve the problem with out of order frame. What is worrying me is that packet with all zeros. I never saw something similar. I'll put my system on test during the next night to see if I can reproduce it. I guess you put the code to reset RX flags in case of error to try to solve this glitch, didn't you?
</I>&gt;<i>
</I>&gt;<i> Anyway I will try your patch tomorrow.
</I>&gt;<i>
</I>&gt;<i> diff --git a/drivers/net/can/mcp251x.c b/drivers/net/can/mcp251x.c index 177f2e1..e8c5e37 100644
</I>&gt;<i> --- a/drivers/net/can/mcp251x.c
</I>&gt;<i> +++ b/drivers/net/can/mcp251x.c
</I>&gt;<i> @@ -773,8 +773,9 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
</I>&gt;<i> &#160; &#160; &#160; &#160;struct mcp251x_priv *priv = dev_id;
</I>&gt;<i> &#160; &#160; &#160; &#160;struct spi_device *spi = priv-&gt;spi;
</I>&gt;<i> &#160; &#160; &#160; &#160;struct net_device *net = priv-&gt;net;
</I>&gt;<i> + &#160; &#160; &#160; u8 intf;
</I>&gt;<i> &#160;#ifdef STATS
</I>&gt;<i> - &#160; &#160; &#160; static int irqs, runs, ov0, ov1, rx0, rx1;
</I>&gt;<i> + &#160; &#160; &#160; static int irqs, runs;
</I>&gt;<i> &#160; &#160; &#160; &#160;static int ee[8], ii[8];
</I>&gt;<i> &#160; &#160; &#160; &#160;static unsigned long last;
</I>&gt;<i> &#160; &#160; &#160; &#160;unsigned long now;
</I>&gt;<i> @@ -788,7 +789,7 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;now = jiffies;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (now &gt;= last + HZ) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;last = now;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; printk(&quot;%lu: i %d r %d r0 %d r1 %d o0 %d o1 %d err&quot;, now, irqs,
</I>&gt;<i> runs, rx0, rx1, ov0, ov1);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; printk(&quot;%lu: i %d r %d err&quot;, now, irqs, runs);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;for(i = 0; i &lt; 8; i++) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printk(&quot;,%d&quot;, ee[i]);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ee[i] = 0;
</I>&gt;<i> @@ -799,24 +800,20 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ii[i] = 0;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printk(&quot;\n&quot;);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; irqs = runs = rx0 = rx1 = ov0 = ov1 = 0;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; irqs = runs = 0;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160;irqs += 1;
</I>&gt;<i> &#160;#endif
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160;mutex_lock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> - &#160; &#160; &#160; while (!priv-&gt;force_quit) {
</I>&gt;<i> + &#160; &#160; &#160; intf = mcp251x_read_reg(spi, CANINTF);
</I>&gt;<i> + &#160; &#160; &#160; do {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;enum can_state new_state;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; u8 intf = mcp251x_read_reg(spi, CANINTF);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; u8 eflag;
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; u8 eflag = 0;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;int can_id = 0, data1 = 0;
</I>&gt;<i> &#160;#ifdef STATS
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;runs += 1;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp; CANINTF_RX0IF)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; rx0 += 1;
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp; CANINTF_RX1IF)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; rx1 += 1;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;int i;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;for(i = 0; i &lt; 8; i++) {
</I>&gt;<i> @@ -828,25 +825,31 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (intf &amp; CANINTF_RX0IF) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_hw_rx(spi, 0);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* Free one buffer ASAP */
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_write_bits(spi, CANINTF, intf &amp; CANINTF_RX0IF,
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;0x00);
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* check that a packet didn't come while emptying RX0 */
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; if ((intf &amp; CANINTF_RX1IF) == 0)
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; intf |= mcp251x_read_reg(spi, CANINTF);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i>
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (intf &amp; CANINTF_RX1IF)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_hw_rx(spi, 1);
</I>&gt;<i>
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* This is needed to close a race condition that causes
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;* packet reordening: we must assure that we never empty
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;* RX0 but not RX1. If this happens the next packet will
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;* land in RX0. As a conseuqence on the next do { } while
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;* spin we will have packets out of order.
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;*/
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; intf |= CANINTF_RX1IF;
</I>&gt;<i> +
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_write_bits(spi, CANINTF, intf, 0x00);
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; eflag = mcp251x_read_reg(spi, EFLG);
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_write_reg(spi, EFLG, 0x00);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf &amp;&amp; CANINTF_ERRIF) {
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; eflag = mcp251x_read_reg(spi, EFLG);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcp251x_write_reg(spi, EFLG, 0x00);
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; }
</I>&gt;<i>
</I>&gt;<i> &#160;#ifdef STATS
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (eflag &amp; EFLG_RX0OVR)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ov0 += 1;
</I>&gt;<i> -
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (eflag &amp; EFLG_RX1OVR)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ov1 += 1;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;{
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;int i;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;for(i = 0; i &lt; 8; i++) {
</I>&gt;<i> @@ -924,9 +927,6 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i>
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; if (intf == 0)
</I>&gt;<i> - &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; break;
</I>&gt;<i> -
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (intf &amp; (CANINTF_TX2IF | CANINTF_TX1IF | CANINTF_TX0IF)) {
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;net-&gt;stats.tx_packets++;
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;net-&gt;stats.tx_bytes += priv-&gt;tx_len - 1; @@ -936,7 +936,8 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;netif_wake_queue(net);
</I>&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;<i> - &#160; &#160; &#160; }
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; intf = mcp251x_read_reg(spi, CANINTF);
</I>&gt;<i> + &#160; &#160; &#160; } while (!priv-&gt;force_quit &amp;&amp; intf);
</I>&gt;<i> &#160; &#160; &#160; &#160;mutex_unlock(&amp;priv-&gt;mcp_lock);
</I>&gt;<i> &#160; &#160; &#160; &#160;return IRQ_HANDLED;
</I>&gt;<i> &#160;}
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> On Sat, Aug 28, 2010 at 2:20 PM, Benny B. Simonsen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">bbs at serenergy.com</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> 2010/8/6 christian pellegrin &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">chripell at gmail.com</A>&gt;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On Fri, Aug 6, 2010 at 3:56 PM, Wolfgang Grandegger
</I>&gt;&gt;&gt;<i> &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">wg at grandegger.com</A>&gt;
</I>&gt;&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;<i> &gt; To be clear, out-of-order messages are also not OK.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Yes I was looking at this with some interleave analysis. I think the
</I>&gt;&gt;&gt;<i> problem lies in the following race:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> // suppose we come here with RXB0 filled with packet X
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;u8 intf = mcp251x_read_reg(spi, CANINTF);
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;u8 eflag;
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;int can_id = 0, data1 = 0;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> // packet X+1 arrives and lands in RXB1
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (intf &amp; CANINTF_RX0IF) {
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_hw_rx(spi, 0);
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* Free one buffer ASAP */
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_write_bits(spi, CANINTF, intf &amp;
</I>&gt;&gt;&gt;<i> CANINTF_RX0IF,
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x00);
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> // packet X+2 arrives and lands in RXB0 // unfortunately variable
</I>&gt;&gt;&gt;<i> intf is old and doesn't show that we have something in RXB1 // (*1)
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (intf &amp; CANINTF_RX1IF)
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_hw_rx(spi, 1);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> now on the next turn we will have packet X+2 in RXB0 and X+1 in RXB1
</I>&gt;&gt;&gt;<i> so we read them out-of-order. The easiest way to solve the problem is
</I>&gt;&gt;&gt;<i> to take out the line:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* Free one buffer ASAP */
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mcp251x_write_bits(spi, CANINTF, intf &amp;
</I>&gt;&gt;&gt;<i> CANINTF_RX0IF,
</I>&gt;&gt;&gt;<i> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 0x00);
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> but we risk to lose more packets. Perhaps also rereading intf in (*1)
</I>&gt;&gt;&gt;<i> could work but we must be careful when we reset CANINTF register to
</I>&gt;&gt;&gt;<i> not lose an interrupt for RXB0. I will do some tests but after next
</I>&gt;&gt;&gt;<i> week because I don't have the access to the hardware until then.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> --
</I>&gt;&gt;&gt;<i> Christian Pellegrin, see <A HREF="http://www.evolware.org/chri/">http://www.evolware.org/chri/</A> &quot;Real
</I>&gt;&gt;&gt;<i> Programmers don't play tennis, or any other sport which requires you
</I>&gt;&gt;&gt;<i> to change clothes. Mountain climbing is OK, and Real Programmers wear
</I>&gt;&gt;&gt;<i> their climbing boots to work in case a mountain should suddenly
</I>&gt;&gt;&gt;<i> spring up in the middle of the computer room.&quot;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Hi Christian,
</I>&gt;&gt;<i> Did you have a chance to look on the problem and / or the patch I send
</I>&gt;&gt;<i> to the list?
</I>&gt;&gt;<i> BR
</I>&gt;&gt;<i> Benny
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> --
</I>&gt;<i> Christian Pellegrin, see <A HREF="http://www.evolware.org/chri/">http://www.evolware.org/chri/</A> &quot;Real Programmers don't play tennis, or any other sport which requires you to change clothes. Mountain climbing is OK, and Real Programmers wear their climbing boots to work in case a mountain should suddenly spring up in the middle of the computer room.&quot;
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Socketcan-users mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">Socketcan-users at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">https://lists.berlios.de/mailman/listinfo/socketcan-users</A>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Socketcan-users mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">Socketcan-users at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/socketcan-users">https://lists.berlios.de/mailman/listinfo/socketcan-users</A>
</I>&gt;<i>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001501.html">[Socketcan-users] MCP 2515 RX problems
</A></li>
	<LI>Next message: <A HREF="001502.html">[Socketcan-users] What is the current &quot;main&quot; SocketCAN repo?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1504">[ date ]</a>
              <a href="thread.html#1504">[ thread ]</a>
              <a href="subject.html#1504">[ subject ]</a>
              <a href="author.html#1504">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/socketcan-users">More information about the Socketcan-users
mailing list</a><br>
</body></html>
